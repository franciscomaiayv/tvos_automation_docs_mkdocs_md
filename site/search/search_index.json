{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to TVOS Automation Tools Here you will find some of the tools developed for the automation of TVOS testing.","title":"Welcome to TVOS Automation Tools"},{"location":"#welcome-to-tvos-automation-tools","text":"Here you will find some of the tools developed for the automation of TVOS testing.","title":"Welcome to TVOS Automation Tools"},{"location":"mediarouter/","text":"Media Router YV Aforementioned is the official documentation for TVOS automation with the MediaRouter. Meant to be a concise representation of all the available methods available. start_daemon() Starting the dbusdaemon. As mentioned above, this is necessary for out MR object to be store and not recycled. dbussenddaemon kill_daemon(): Kills daemon. Send a dbus-message to the void send method. this does not care about any of the ssh output killall dbussenddaemon get_media_factory_address() Gets the MR address this sends a message through the dbus and returns the generated MR address. this will also be stored in the dbus daemon. Returns: string: generated MR address - 'Zinc/Media/MediaRouters/X' Same as executing in UNIX: dbus-send --session --print-reply --dest='Zinc.DBusSendDaemon' \\ /Zinc/Media/MediaRouterFactory \\ Zinc.Media.MediaRouterFactory.createMediaRouter string:Zinc.Media \\ string: Zinc/Media/MediaRouters/ \\ deactivate_tuner() Deactivate tuner Sends a dbus message that soft deactivates the inboard DTT tuner. Returns: string: the output of the dbus send command, might throw error but it must be caught by the automation script MediaRouterErrors(Enum) This is a class that lists known errors, extremely useful for creating human readable test. You can add new errors in this format: MediaRouterErrors.InvalidLocator = Zinc.Media.Error.InvalidLocator A example usage for this is as such: with then( I call MediaRouter.setSink() and THEN MediaRouter.setSink() returns an error: Zinc.Media.Error.IllegalReconfiguration ): if not MR.set_sink( string:decoder://0 ) == MediaRouterErrors.IllegalReconfiguration: fail( Zinc.Media.Error.IllegalReconfiguration not returned ) class MediaRouter Media router class for TVOS automation. Can be initialised from a test. all sorts of interfaces are available. We can generate, and modify a media router on demand. please note that we will often abbreviate Media router as MR. MediaRouter. init () Construsctor for the MediaRouter class A bit longer description. We start a deamon. this daemon will store our new MR adress. dbus tends to recycle any generated object. So for us to store the reference to out generated MR we must start this dbus daemon. We also store the MR address locally. MediaRouter.get_mr(self) Returns the MR address in use Returns: string: generated MR address - 'Zinc/Media/MediaRouters/X' MediaRouter.recycle(self) This will send a dbus command with the current MR and request a recycle. we might timeout but this error must be handled by the automation script. Args: variable (type): description Returns: str(stdout): the output of the dbus send command. Same as executing: dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.recycle MediaRouter.start(self): Sends a dbus message that starts the MR we generated Returns: string: the dbus send output. this can throw an error but it must be caught by automation script MediaRouter.set_sink(self, string): Sends a dbus message that sets the sink Can throw an error but it must be caught by automation script Args: sink (string): MR sink variable Return: classified error, as a MediaRouterErrors object. Same as executing: dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.setSink string:decoder://0 MediaRouter.get_sink(self) Returns the current sink set in the MR Can throw an error but it must be caught by automation script Returns: string: dbus send response Same as executing: dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.getSink MediaRouter.stop(self) Sends a stop signal to the current MR Can throw an error but it must be caught by automation script Returns: string: dbus response Same as executing: dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' '/Zinc/Media/MediaRouters/X' Zinc.Media.MediaRouter.start MediaRouter.set_source_and_play(self, uri) Set source and play Executes a compiled list of arguments that prepares a MR, sets a custom URI as its source and plays it. Args: URI (string): a uri for the media we should play MediaRouter.get_source(self) Get source Sends a dbus message that will return the source of the current MR Returns: source (string): uri for the current MR MediaRouter.get_playspeed(self) Sends a dbus message that will return the play speed of the current MR Returns: playSpeed (string): play speed for the current MR Same as executing: dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.getPlaySpeed MediaRouter.call_custom_method(self, method, *args ) Call a custom method Sends a dbus message that will call on a methods specified Arguments can be trailed to that argument. Do note that arguments have to be \"pre parsed\" so: if you want to send, string:'a/string/to/send' or int32:100 you must, call_custom_method( methodToCall , string:'a/string/to/send' , int32:100 ) which will result in, dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.methodToCall string:'a/string/to/send' int32:100 Returns: method response (string): method's response MediaRouter.set_source(self, uri) Sets the source for the current MR. we can use this for overiding the current source too, although this will likely break the MR It will returned a classified error or a response string. Args: URI (string): uri for the media we wish to set for the MR dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.setSource string: http://filegateway.youview.co.uk/test_assets/restricted/VA-237.mpg int32:0 MediaRouter.set_source_with_int(self, uri, integer) This will set the source for the current MR and append a int to the dbus arguments, this is useful for some tests that require this. Args: uri (string): uri for the media to set this MR for integer (string): additional argument for the dbus send dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.setSource string: http://filegateway.youview.co.uk/test_assets/restricted/VA-237.mpg int32:0 MediaRouter.seek_position(self, arg) Send a dbus message with a sink argument. this will call on the seek position method. It will returned a classified error or a response string. Args: arg (string): seek arguments dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.seekPosition int32:1 int32:600000 int32:4 MediaRouter.get_buffer_status(self) Sends a dbus message that will return the buffer status of the current MR. Returns: buffer status (string): buffer status for the current MR dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.getBufferStatus MediaRouter.get_position(self) sends a dbus message that will return the position of the current MR Returns: position (string): media position for the current MR dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.getPosition MediaRouter.start_buffering(self) Sends a dbus message that will start the buffering of the current MR Returns: buffer start buerring (string): buffering start response dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.startBuffering MediaRouter.set_media_duration(self, arg) This will send a message through the dbus that sets a MR duration Args: arg (string): a set of arguments to add onto them setMediaDuration call dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.setMediaDuration int32:-1 MediaRouter.cleanup(self) This will perform some internal methods that clean the generated MR. this is useful in between tests or on thrown errors. This does, self.stop() self.recycle() Tests Example Here you will find two tests. Please Have a look through these. They were selected because they are great showcases of the capabilities of the MediaRouter library. These tests inlcude: import logging import time from utils.testing import ( fail, given, then, when ) from tvos.mediarouter import ( MediaRouter, MediaRouterErrors ) from nextgen.video_signal import ( wait_for_video, wait_for_no_video ) import recover logger = logging.getLogger(__name__) Test #1 @attr(trid= C496887 , labels=(TL.YOUVIEW_SPECIFICATION_TESTS, TL.SSH)) def run_test_recycle_active_mr(): try: with given( Spec Paragraph/Functional Area: MediaRouter Specification (1125-S) Version 1.3E, Section 4.5, GIVEN STB is connected to an display device through HDMI AND I create a PDL MediaRouter and start it ): MR = MediaRouter() MR.set_source_and_play( http://filegateway.youview.co.uk/test_assets/licence_free/VA-503.ts ) wait_for_video(20) time.sleep(20) with when( WHEN I call MediaRouter.recycle() ): MR.recycle() with then( THEN the video output on the connected display device will be blanked ): wait_for_no_video(20) MR.cleanup() except: MR.cleanup() Test #2 @attr(trid= C496887 , labels=(TL.YOUVIEW_SPECIFICATION_TESTS, TL.SSH)) def run_test_recycle_active_mr(): try: with given( Spec Paragraph/Functional Area: MediaRouter Specification (1125-S) Version 1.3E, Section 4.5, GIVEN STB is connected to an display device through HDMI AND I create a PDL MediaRouter and start it ): MR = MediaRouter() MR.set_source_and_play( http://filegateway.youview.co.uk/test_assets/licence_free/VA-503.ts ) wait_for_video(20) time.sleep(20) with when( WHEN I call MediaRouter.recycle() ): MR.recycle() with then( THEN the video output on the connected display device will be blanked ): wait_for_no_video(20) MR.cleanup() except: MR.cleanup() Test #3 Error detection is a big part of TVOS testing. In the following test we will showcase how we can detect a non included error. The test goes as follows: @attr(trid= C496874 , labels=(TL.YOUVIEW_SPECIFICATION_TESTS, TL.SSH)) def run_test_invalid_enumeration(): with given( Spec Paragraph/Functional Area: MediaRouter Specification (1125-S) Version 1.3E, Annex A MediaRouter API, A.1.19, I create a PDL MediaRouter: ): MR = MediaRouter() MR.set_source( http://filegateway.youview.co.uk/test_assets/restricted/VA-237.mpg ) MR.set_sink( string:decoder://0 ) pass with then( THEN MediaRouter.seekPosition() with invalid arguments returns an error: Zinc.Media.Error.InvalidEnumeration ): if not MR.seek_position( int32:1 , int32:600000 , int32:4 ) == MediaRouterErrors.InvalidEnumeration: fail( No error returned ) pass with when( AND I call MediaRouter.start() ): MR.start() pass with when( AND MediaRouter.seekPosition() with invalid arguments returns an error: Zinc.Media.Error.InvalidEnumeration ): if not MR.seek_position( int32:7 , int32:600000 , int32:1 ) == MediaRouterErrors.InvalidEnumeration: fail( No error returned ) pass The above test gets a dbus resoonse like this: Error org.freedesktop.DBus.Error.InvalidArgs: Could not convert int- enum\\c Invalid enum value This error is not known, so we can listen to it as follows: @attr(trid= C496874 , labels=(TL.YOUVIEW_SPECIFICATION_TESTS, TL.SSH)) def run_test_invalid_enumeration_force_error(): with given( Spec Paragraph/Functional Area: MediaRouter Specification (1125-S) Version 1.3E, Annex A MediaRouter API, A.1.19, I create a PDL MediaRouter: ): MR = MediaRouter() MR.set_source( http://filegateway.youview.co.uk/test_assets/restricted/VA-237.mpg ) MR.set_sink( string:decoder://0 ) pass with then( THEN MediaRouter.seekPosition() with invalid arguments returns an error: Zinc.Media.Error.InvalidEnumeration ): if not org.freedesktop.DBus.Error.InvalidArgs in MR.seek_position( int32:1 , int32:600000 , int32:4 ): fail( No error returned ) pass with when( AND I call MediaRouter.start() ): MR.start() pass with when( AND MediaRouter.seekPosition() with invalid arguments returns an error: Zinc.Media.Error.InvalidEnumeration ): if not org.freedesktop.DBus.Error.InvalidArgs in MR.seek_position( int32:7 , int32:600000 , int32:1 ): fail( No error returned ) pass","title":"MediaRouter Library"},{"location":"mediarouter/#media-router-yv","text":"Aforementioned is the official documentation for TVOS automation with the MediaRouter. Meant to be a concise representation of all the available methods available.","title":"Media Router YV"},{"location":"mediarouter/#start_daemon","text":"Starting the dbusdaemon. As mentioned above, this is necessary for out MR object to be store and not recycled. dbussenddaemon","title":"start_daemon()"},{"location":"mediarouter/#kill_daemon","text":"Kills daemon. Send a dbus-message to the void send method. this does not care about any of the ssh output killall dbussenddaemon","title":"kill_daemon():"},{"location":"mediarouter/#get_media_factory_address","text":"Gets the MR address this sends a message through the dbus and returns the generated MR address. this will also be stored in the dbus daemon. Returns: string: generated MR address - 'Zinc/Media/MediaRouters/X' Same as executing in UNIX: dbus-send --session --print-reply --dest='Zinc.DBusSendDaemon' \\ /Zinc/Media/MediaRouterFactory \\ Zinc.Media.MediaRouterFactory.createMediaRouter string:Zinc.Media \\ string: Zinc/Media/MediaRouters/ \\","title":"get_media_factory_address()"},{"location":"mediarouter/#deactivate_tuner","text":"Deactivate tuner Sends a dbus message that soft deactivates the inboard DTT tuner. Returns: string: the output of the dbus send command, might throw error but it must be caught by the automation script","title":"deactivate_tuner()"},{"location":"mediarouter/#mediaroutererrorsenum","text":"This is a class that lists known errors, extremely useful for creating human readable test. You can add new errors in this format: MediaRouterErrors.InvalidLocator = Zinc.Media.Error.InvalidLocator A example usage for this is as such: with then( I call MediaRouter.setSink() and THEN MediaRouter.setSink() returns an error: Zinc.Media.Error.IllegalReconfiguration ): if not MR.set_sink( string:decoder://0 ) == MediaRouterErrors.IllegalReconfiguration: fail( Zinc.Media.Error.IllegalReconfiguration not returned )","title":"MediaRouterErrors(Enum)"},{"location":"mediarouter/#class-mediarouter","text":"Media router class for TVOS automation. Can be initialised from a test. all sorts of interfaces are available. We can generate, and modify a media router on demand. please note that we will often abbreviate Media router as MR.","title":"class MediaRouter"},{"location":"mediarouter/#mediarouterinit","text":"Construsctor for the MediaRouter class A bit longer description. We start a deamon. this daemon will store our new MR adress. dbus tends to recycle any generated object. So for us to store the reference to out generated MR we must start this dbus daemon. We also store the MR address locally.","title":"MediaRouter.init()"},{"location":"mediarouter/#mediarouterget_mrself","text":"Returns the MR address in use Returns: string: generated MR address - 'Zinc/Media/MediaRouters/X'","title":"MediaRouter.get_mr(self)"},{"location":"mediarouter/#mediarouterrecycleself","text":"This will send a dbus command with the current MR and request a recycle. we might timeout but this error must be handled by the automation script. Args: variable (type): description Returns: str(stdout): the output of the dbus send command. Same as executing: dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.recycle","title":"MediaRouter.recycle(self)"},{"location":"mediarouter/#mediarouterstartself","text":"Sends a dbus message that starts the MR we generated Returns: string: the dbus send output. this can throw an error but it must be caught by automation script","title":"MediaRouter.start(self):"},{"location":"mediarouter/#mediarouterset_sinkself-string","text":"Sends a dbus message that sets the sink Can throw an error but it must be caught by automation script Args: sink (string): MR sink variable Return: classified error, as a MediaRouterErrors object. Same as executing: dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.setSink string:decoder://0","title":"MediaRouter.set_sink(self, string):"},{"location":"mediarouter/#mediarouterget_sinkself","text":"Returns the current sink set in the MR Can throw an error but it must be caught by automation script Returns: string: dbus send response Same as executing: dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.getSink","title":"MediaRouter.get_sink(self)"},{"location":"mediarouter/#mediarouterstopself","text":"Sends a stop signal to the current MR Can throw an error but it must be caught by automation script Returns: string: dbus response Same as executing: dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' '/Zinc/Media/MediaRouters/X' Zinc.Media.MediaRouter.start","title":"MediaRouter.stop(self)"},{"location":"mediarouter/#mediarouterset_source_and_playself-uri","text":"Set source and play Executes a compiled list of arguments that prepares a MR, sets a custom URI as its source and plays it. Args: URI (string): a uri for the media we should play","title":"MediaRouter.set_source_and_play(self, uri)"},{"location":"mediarouter/#mediarouterget_sourceself","text":"Get source Sends a dbus message that will return the source of the current MR Returns: source (string): uri for the current MR","title":"MediaRouter.get_source(self)"},{"location":"mediarouter/#mediarouterget_playspeedself","text":"Sends a dbus message that will return the play speed of the current MR Returns: playSpeed (string): play speed for the current MR Same as executing: dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.getPlaySpeed","title":"MediaRouter.get_playspeed(self)"},{"location":"mediarouter/#mediaroutercall_custom_methodself-method-args","text":"Call a custom method Sends a dbus message that will call on a methods specified Arguments can be trailed to that argument. Do note that arguments have to be \"pre parsed\" so: if you want to send, string:'a/string/to/send' or int32:100 you must, call_custom_method( methodToCall , string:'a/string/to/send' , int32:100 ) which will result in, dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.methodToCall string:'a/string/to/send' int32:100 Returns: method response (string): method's response","title":"MediaRouter.call_custom_method(self, method, *args)"},{"location":"mediarouter/#mediarouterset_sourceself-uri","text":"Sets the source for the current MR. we can use this for overiding the current source too, although this will likely break the MR It will returned a classified error or a response string. Args: URI (string): uri for the media we wish to set for the MR dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.setSource string: http://filegateway.youview.co.uk/test_assets/restricted/VA-237.mpg int32:0","title":"MediaRouter.set_source(self, uri)"},{"location":"mediarouter/#mediarouterset_source_with_intself-uri-integer","text":"This will set the source for the current MR and append a int to the dbus arguments, this is useful for some tests that require this. Args: uri (string): uri for the media to set this MR for integer (string): additional argument for the dbus send dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.setSource string: http://filegateway.youview.co.uk/test_assets/restricted/VA-237.mpg int32:0","title":"MediaRouter.set_source_with_int(self, uri, integer)"},{"location":"mediarouter/#mediarouterseek_positionself-arg","text":"Send a dbus message with a sink argument. this will call on the seek position method. It will returned a classified error or a response string. Args: arg (string): seek arguments dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.seekPosition int32:1 int32:600000 int32:4","title":"MediaRouter.seek_position(self, arg)"},{"location":"mediarouter/#mediarouterget_buffer_statusself","text":"Sends a dbus message that will return the buffer status of the current MR. Returns: buffer status (string): buffer status for the current MR dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.getBufferStatus","title":"MediaRouter.get_buffer_status(self)"},{"location":"mediarouter/#mediarouterget_positionself","text":"sends a dbus message that will return the position of the current MR Returns: position (string): media position for the current MR dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.getPosition","title":"MediaRouter.get_position(self)"},{"location":"mediarouter/#mediarouterstart_bufferingself","text":"Sends a dbus message that will start the buffering of the current MR Returns: buffer start buerring (string): buffering start response dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.startBuffering","title":"MediaRouter.start_buffering(self)"},{"location":"mediarouter/#mediarouterset_media_durationself-arg","text":"This will send a message through the dbus that sets a MR duration Args: arg (string): a set of arguments to add onto them setMediaDuration call dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' $MR Zinc.Media.MediaRouter.setMediaDuration int32:-1","title":"MediaRouter.set_media_duration(self, arg)"},{"location":"mediarouter/#mediaroutercleanupself","text":"This will perform some internal methods that clean the generated MR. this is useful in between tests or on thrown errors. This does, self.stop() self.recycle()","title":"MediaRouter.cleanup(self)"},{"location":"mediarouter/#tests-example","text":"Here you will find two tests. Please Have a look through these. They were selected because they are great showcases of the capabilities of the MediaRouter library. These tests inlcude: import logging import time from utils.testing import ( fail, given, then, when ) from tvos.mediarouter import ( MediaRouter, MediaRouterErrors ) from nextgen.video_signal import ( wait_for_video, wait_for_no_video ) import recover logger = logging.getLogger(__name__)","title":"Tests Example"},{"location":"mediarouter/#test-1","text":"@attr(trid= C496887 , labels=(TL.YOUVIEW_SPECIFICATION_TESTS, TL.SSH)) def run_test_recycle_active_mr(): try: with given( Spec Paragraph/Functional Area: MediaRouter Specification (1125-S) Version 1.3E, Section 4.5, GIVEN STB is connected to an display device through HDMI AND I create a PDL MediaRouter and start it ): MR = MediaRouter() MR.set_source_and_play( http://filegateway.youview.co.uk/test_assets/licence_free/VA-503.ts ) wait_for_video(20) time.sleep(20) with when( WHEN I call MediaRouter.recycle() ): MR.recycle() with then( THEN the video output on the connected display device will be blanked ): wait_for_no_video(20) MR.cleanup() except: MR.cleanup()","title":"Test #1"},{"location":"mediarouter/#test-2","text":"@attr(trid= C496887 , labels=(TL.YOUVIEW_SPECIFICATION_TESTS, TL.SSH)) def run_test_recycle_active_mr(): try: with given( Spec Paragraph/Functional Area: MediaRouter Specification (1125-S) Version 1.3E, Section 4.5, GIVEN STB is connected to an display device through HDMI AND I create a PDL MediaRouter and start it ): MR = MediaRouter() MR.set_source_and_play( http://filegateway.youview.co.uk/test_assets/licence_free/VA-503.ts ) wait_for_video(20) time.sleep(20) with when( WHEN I call MediaRouter.recycle() ): MR.recycle() with then( THEN the video output on the connected display device will be blanked ): wait_for_no_video(20) MR.cleanup() except: MR.cleanup()","title":"Test #2"},{"location":"mediarouter/#test-3","text":"Error detection is a big part of TVOS testing. In the following test we will showcase how we can detect a non included error. The test goes as follows: @attr(trid= C496874 , labels=(TL.YOUVIEW_SPECIFICATION_TESTS, TL.SSH)) def run_test_invalid_enumeration(): with given( Spec Paragraph/Functional Area: MediaRouter Specification (1125-S) Version 1.3E, Annex A MediaRouter API, A.1.19, I create a PDL MediaRouter: ): MR = MediaRouter() MR.set_source( http://filegateway.youview.co.uk/test_assets/restricted/VA-237.mpg ) MR.set_sink( string:decoder://0 ) pass with then( THEN MediaRouter.seekPosition() with invalid arguments returns an error: Zinc.Media.Error.InvalidEnumeration ): if not MR.seek_position( int32:1 , int32:600000 , int32:4 ) == MediaRouterErrors.InvalidEnumeration: fail( No error returned ) pass with when( AND I call MediaRouter.start() ): MR.start() pass with when( AND MediaRouter.seekPosition() with invalid arguments returns an error: Zinc.Media.Error.InvalidEnumeration ): if not MR.seek_position( int32:7 , int32:600000 , int32:1 ) == MediaRouterErrors.InvalidEnumeration: fail( No error returned ) pass The above test gets a dbus resoonse like this: Error org.freedesktop.DBus.Error.InvalidArgs: Could not convert int- enum\\c Invalid enum value This error is not known, so we can listen to it as follows: @attr(trid= C496874 , labels=(TL.YOUVIEW_SPECIFICATION_TESTS, TL.SSH)) def run_test_invalid_enumeration_force_error(): with given( Spec Paragraph/Functional Area: MediaRouter Specification (1125-S) Version 1.3E, Annex A MediaRouter API, A.1.19, I create a PDL MediaRouter: ): MR = MediaRouter() MR.set_source( http://filegateway.youview.co.uk/test_assets/restricted/VA-237.mpg ) MR.set_sink( string:decoder://0 ) pass with then( THEN MediaRouter.seekPosition() with invalid arguments returns an error: Zinc.Media.Error.InvalidEnumeration ): if not org.freedesktop.DBus.Error.InvalidArgs in MR.seek_position( int32:1 , int32:600000 , int32:4 ): fail( No error returned ) pass with when( AND I call MediaRouter.start() ): MR.start() pass with when( AND MediaRouter.seekPosition() with invalid arguments returns an error: Zinc.Media.Error.InvalidEnumeration ): if not org.freedesktop.DBus.Error.InvalidArgs in MR.seek_position( int32:7 , int32:600000 , int32:1 ): fail( No error returned ) pass","title":"Test #3"},{"location":"sniffer/","text":"CEC Sniffer Libray This module will connect to a kwikwai device using its web api. kwikwai constanyl writes new blocks in order and thus we can query the upcoming block, whicever is the new block we consider it to be new. This module works in an async and a sync way, yes kinda like node js :) class CecSniffer: Parameters hostname : string the URL of the kwikwai device, aboid ntebios and bonjour on unix Attributes current_last_message : string the current buffer we query (new block appears here) messages : obj messages inside each block token : int random int from kiwkwai, used as auth token hostname init (self, hostname) Parameters hostname : string the URL of the kwikwai device, avoid ntebios and bonjour on unix Returns none constructs :o begin_listen(self,cec_bus_listener,cec_bus_listener_keepalive,cec_sniffer_killed,cec_sniffer_started): Parameters cec_bus_listener : callback for ASYNC, will be called on new message cec_bus_listener_keepalive : callback for ASYNC will be called to avoid test forever cec_sniffer_killed : callback for AYNC, to be called when listener killed gracefully cec_sniffer_started : callback for ASYNC, to be called on new listener Returns class the constructed class sync_messages_local(self) This is the secret sauce, this should be called on each module start as this will check all the previous blocks of data in the kwikwai buffer and import them into a local variable. this is so we can keep checking for new blocks and use our local blocks to compare any new ones that appear in kwikwais memory Returns json no return send_message(self, message) sends a message through a POST. we also sniff the token to include in this post Parameters message : string the message to seng Returns true return true, for non blocking wait_for_next(self) link for the non persistant_query Returns block (json) will return the messsage wait_for_next_rx(self, message) link for the non persistant_query but will also send a message. will raise rx flag Parameters message : json message to send to kwikwai Returns json Description of returned object. beta_interpreter(self, block) will attempt to convert a recieved message into json Parameters block : json block of recieved data from kwikwai Returns json obj with interpreted messages from kwikwai, format is set below Tests (Sample) Async Sample def CEC_bus_listener_keepalive(last_block_index): print( ~ Quering CEC bus for blocks after - + str(last_block_index)) def CEC_bus_listener(block): print(block) CEC_block_interpreter(block) def CEC_sniffer_killed(): print( ~ Trying blocking argument, synchronous waiting for next... ) print(sniffer.wait_for_next()) def CEC_sniffer_started(): print( ~ Persistant Listener Started ) def CEC_block_interpreter(block): for message in block[ messages ]: readeable_hex = [] for block in message[ blocks ]: if(len(str(hex(int(block)))) 6): readeable_hex.append( 00 ) else: readeable_hex.append(str(hex(int(block)))[2:-2]) print( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ) print( Message (human readeable not correct)- + : .join(readeable_hex)) sent_or_not = TX if(message[ sent ]==False): sent_or_not = RX print( RX/TX - + sent_or_not) print( Bus - + message[ bus ]) print( ~ Syncing previous sniffed blocks...wait... ) sniffer = CEC_Sniffer( http://172.20.44.138 ) #no NetBIOS or Bonjour on linux :( sniffer.sync_messages_local() sniffer.begin_listen(CEC_bus_listener, CEC_bus_listener_keepalive, CEC_sniffer_killed, CEC_sniffer_started) Sync/Blocking Example def set_up_interface(hostname): try: sniffer = CEC_Sniffer(hostname) #no NetBIOS or Bonjour on linux :( logger.debug( [cec-sniffer] Percussively inspecting CEC bus buffer... ) sniffer.sync_messages_local() logger.debug( [cec-sniffer] Buffer synced! ) return sniffer except: fail( CEC Interface Error ) cec_listener = set_up_interface(hostname) for message in cec_listener.wait_for_next_rx( 2F:85:20:00 ): message_parsed = cec_listener.beta_interpreter(message) print(message_parsed) Sync Sample No RX Expectance def set_up_interface(hostname): try: sniffer = CEC_Sniffer(hostname) #no NetBIOS or Bonjour on linux :( logger.debug( [cec-sniffer] Percussively inspecting CEC bus buffer... ) sniffer.sync_messages_local() logger.debug( [cec-sniffer] Buffer synced! ) return sniffer except: fail( CEC Interface Error ) cec_listener.send_message( 2F:85:20:00 ) cec_listener = set_up_interface(hostname) for message in cec_listener.wait_for_next(): message_parsed = cec_listener.beta_interpreter(message) print(message_parsed) Full Test Implementation Sample from tvos.cec_sniffer import CecSniffer #Must include import logging import matplotlib matplotlib.use('agg') import matplotlib.pyplot as plt import common from testcases import attr from utils.testing import fail, given, then, when @attr(trid= C497220 ) def set_up_interface(hostname): try: sniffer = CecSniffer(hostname) #no NetBIOS or Bonjour on linux :( logger.debug( [cec-sniffer] Percussively inspecting CEC bus buffer... ) sniffer.sync_messages_local() logger.debug( [cec-sniffer] Buffer synced! ) return sniffer except: fail( CEC Interface Error ) def cec_test(hostname= http://172.20.44.138 ): cec_listener = set_up_interface(hostname) with given( The STB is connected through HDMI to a device that displays and decodes CEC messages exchanged between devices on the HDMI bus: Ref: https://wiki.youview.co.uk/display/canvas/Using+the+Kwikwai+device+to+inspect+HDMI+CEC+messages Note: Please ensure HDMI 1 on the TV is used during setup. AND the STB is the HDMI Active source To check that STB hdmi-cec-state is Active , send an HDMI CEC Request Active Source message on the CEC device e.g 2F:85:20:00 and the STB should respond by broadcasting an HDMI CEC Active Source message 3F:82:10:00 ): sent_message = False recieved_message = False for message in cec_listener.wait_for_next_rx( 2F:85:20:00 ): message_parsed = cec_listener.beta_interpreter(message) print(message_parsed) try: if message_parsed[ direction ] == TX and message_parsed[ message ] == 2f:85:20:00 : sent_message = True if message_parsed[ direction ] == RX and message_parsed[ message ].split( : )[1] == 82 : recieved_message = True except Exception as e: fail('Error decoding messages') preconditions_output = { sent_message : sent_message, recieved_message : recieved_message } print(preconditions_output) if not (sent_message and recieved_message): #raise common.InvalidTest('Could not check STB is the HDMI active source, probably because we have a splitter inline') logger.debug('Could not check STB is the HDMI active source, probably because we have a splitter inline') #fail( Could not check STB is the HDMI active source ) with when( I send an HDMI CEC Request Active Source message on the CEC device: ): print( Testing beta feature ) with then( The STB will broadcast an HDMI CEC Active Source (82) message ): sent_message = False recieved_message = False for message in cec_listener.wait_for_next_rx( 4F:85:30:00 ): message_parsed = cec_listener.beta_interpreter(message) print(message_parsed) try: if message_parsed[ direction ] == TX and message_parsed[ message ] == 4f:85:30:00 : sent_message = True if message_parsed[ direction ] == RX and message_parsed[ message ].split( : )[1] == 82 : #We can simply check the message ID from the 2nd block and return the correct request Active Source (Brodcast). recieved_message = True except: fail( Failed on awaiting Active Source (82), check combined log ) if not (sent_message and recieved_message): preconditions_output = { sent_message : sent_message, recieved_message : recieved_message } logger.debug(preconditions_output) fail( Failed on awaiting Active Source (82), check combined log )","title":"CEC Sniffer Library"},{"location":"sniffer/#cec-sniffer-libray","text":"This module will connect to a kwikwai device using its web api. kwikwai constanyl writes new blocks in order and thus we can query the upcoming block, whicever is the new block we consider it to be new. This module works in an async and a sync way, yes kinda like node js :)","title":"CEC Sniffer Libray"},{"location":"sniffer/#class-cecsniffer","text":"Parameters hostname : string the URL of the kwikwai device, aboid ntebios and bonjour on unix Attributes current_last_message : string the current buffer we query (new block appears here) messages : obj messages inside each block token : int random int from kiwkwai, used as auth token hostname","title":"class CecSniffer:"},{"location":"sniffer/#initself-hostname","text":"Parameters hostname : string the URL of the kwikwai device, avoid ntebios and bonjour on unix Returns none constructs :o","title":"init(self, hostname)"},{"location":"sniffer/#begin_listenselfcec_bus_listenercec_bus_listener_keepalivecec_sniffer_killedcec_sniffer_started","text":"Parameters cec_bus_listener : callback for ASYNC, will be called on new message cec_bus_listener_keepalive : callback for ASYNC will be called to avoid test forever cec_sniffer_killed : callback for AYNC, to be called when listener killed gracefully cec_sniffer_started : callback for ASYNC, to be called on new listener Returns class the constructed class","title":"begin_listen(self,cec_bus_listener,cec_bus_listener_keepalive,cec_sniffer_killed,cec_sniffer_started):"},{"location":"sniffer/#sync_messages_localself","text":"This is the secret sauce, this should be called on each module start as this will check all the previous blocks of data in the kwikwai buffer and import them into a local variable. this is so we can keep checking for new blocks and use our local blocks to compare any new ones that appear in kwikwais memory Returns json no return","title":"sync_messages_local(self)"},{"location":"sniffer/#send_messageself-message","text":"sends a message through a POST. we also sniff the token to include in this post Parameters message : string the message to seng Returns true return true, for non blocking","title":"send_message(self, message)"},{"location":"sniffer/#wait_for_nextself","text":"link for the non persistant_query Returns block (json) will return the messsage","title":"wait_for_next(self)"},{"location":"sniffer/#wait_for_next_rxself-message","text":"link for the non persistant_query but will also send a message. will raise rx flag Parameters message : json message to send to kwikwai Returns json Description of returned object.","title":"wait_for_next_rx(self, message)"},{"location":"sniffer/#beta_interpreterself-block","text":"will attempt to convert a recieved message into json Parameters block : json block of recieved data from kwikwai Returns json obj with interpreted messages from kwikwai, format is set below","title":"beta_interpreter(self, block)"},{"location":"sniffer/#tests-sample","text":"","title":"Tests (Sample)"},{"location":"sniffer/#async-sample","text":"def CEC_bus_listener_keepalive(last_block_index): print( ~ Quering CEC bus for blocks after - + str(last_block_index)) def CEC_bus_listener(block): print(block) CEC_block_interpreter(block) def CEC_sniffer_killed(): print( ~ Trying blocking argument, synchronous waiting for next... ) print(sniffer.wait_for_next()) def CEC_sniffer_started(): print( ~ Persistant Listener Started ) def CEC_block_interpreter(block): for message in block[ messages ]: readeable_hex = [] for block in message[ blocks ]: if(len(str(hex(int(block)))) 6): readeable_hex.append( 00 ) else: readeable_hex.append(str(hex(int(block)))[2:-2]) print( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ) print( Message (human readeable not correct)- + : .join(readeable_hex)) sent_or_not = TX if(message[ sent ]==False): sent_or_not = RX print( RX/TX - + sent_or_not) print( Bus - + message[ bus ]) print( ~ Syncing previous sniffed blocks...wait... ) sniffer = CEC_Sniffer( http://172.20.44.138 ) #no NetBIOS or Bonjour on linux :( sniffer.sync_messages_local() sniffer.begin_listen(CEC_bus_listener, CEC_bus_listener_keepalive, CEC_sniffer_killed, CEC_sniffer_started)","title":"Async Sample"},{"location":"sniffer/#syncblocking-example","text":"def set_up_interface(hostname): try: sniffer = CEC_Sniffer(hostname) #no NetBIOS or Bonjour on linux :( logger.debug( [cec-sniffer] Percussively inspecting CEC bus buffer... ) sniffer.sync_messages_local() logger.debug( [cec-sniffer] Buffer synced! ) return sniffer except: fail( CEC Interface Error ) cec_listener = set_up_interface(hostname) for message in cec_listener.wait_for_next_rx( 2F:85:20:00 ): message_parsed = cec_listener.beta_interpreter(message) print(message_parsed)","title":"Sync/Blocking Example"},{"location":"sniffer/#sync-sample-no-rx-expectance","text":"def set_up_interface(hostname): try: sniffer = CEC_Sniffer(hostname) #no NetBIOS or Bonjour on linux :( logger.debug( [cec-sniffer] Percussively inspecting CEC bus buffer... ) sniffer.sync_messages_local() logger.debug( [cec-sniffer] Buffer synced! ) return sniffer except: fail( CEC Interface Error ) cec_listener.send_message( 2F:85:20:00 ) cec_listener = set_up_interface(hostname) for message in cec_listener.wait_for_next(): message_parsed = cec_listener.beta_interpreter(message) print(message_parsed)","title":"Sync Sample No RX Expectance"},{"location":"sniffer/#full-test-implementation-sample","text":"from tvos.cec_sniffer import CecSniffer #Must include import logging import matplotlib matplotlib.use('agg') import matplotlib.pyplot as plt import common from testcases import attr from utils.testing import fail, given, then, when @attr(trid= C497220 ) def set_up_interface(hostname): try: sniffer = CecSniffer(hostname) #no NetBIOS or Bonjour on linux :( logger.debug( [cec-sniffer] Percussively inspecting CEC bus buffer... ) sniffer.sync_messages_local() logger.debug( [cec-sniffer] Buffer synced! ) return sniffer except: fail( CEC Interface Error ) def cec_test(hostname= http://172.20.44.138 ): cec_listener = set_up_interface(hostname) with given( The STB is connected through HDMI to a device that displays and decodes CEC messages exchanged between devices on the HDMI bus: Ref: https://wiki.youview.co.uk/display/canvas/Using+the+Kwikwai+device+to+inspect+HDMI+CEC+messages Note: Please ensure HDMI 1 on the TV is used during setup. AND the STB is the HDMI Active source To check that STB hdmi-cec-state is Active , send an HDMI CEC Request Active Source message on the CEC device e.g 2F:85:20:00 and the STB should respond by broadcasting an HDMI CEC Active Source message 3F:82:10:00 ): sent_message = False recieved_message = False for message in cec_listener.wait_for_next_rx( 2F:85:20:00 ): message_parsed = cec_listener.beta_interpreter(message) print(message_parsed) try: if message_parsed[ direction ] == TX and message_parsed[ message ] == 2f:85:20:00 : sent_message = True if message_parsed[ direction ] == RX and message_parsed[ message ].split( : )[1] == 82 : recieved_message = True except Exception as e: fail('Error decoding messages') preconditions_output = { sent_message : sent_message, recieved_message : recieved_message } print(preconditions_output) if not (sent_message and recieved_message): #raise common.InvalidTest('Could not check STB is the HDMI active source, probably because we have a splitter inline') logger.debug('Could not check STB is the HDMI active source, probably because we have a splitter inline') #fail( Could not check STB is the HDMI active source ) with when( I send an HDMI CEC Request Active Source message on the CEC device: ): print( Testing beta feature ) with then( The STB will broadcast an HDMI CEC Active Source (82) message ): sent_message = False recieved_message = False for message in cec_listener.wait_for_next_rx( 4F:85:30:00 ): message_parsed = cec_listener.beta_interpreter(message) print(message_parsed) try: if message_parsed[ direction ] == TX and message_parsed[ message ] == 4f:85:30:00 : sent_message = True if message_parsed[ direction ] == RX and message_parsed[ message ].split( : )[1] == 82 : #We can simply check the message ID from the 2nd block and return the correct request Active Source (Brodcast). recieved_message = True except: fail( Failed on awaiting Active Source (82), check combined log ) if not (sent_message and recieved_message): preconditions_output = { sent_message : sent_message, recieved_message : recieved_message } logger.debug(preconditions_output) fail( Failed on awaiting Active Source (82), check combined log )","title":"Full Test Implementation Sample"},{"location":"video_listener/","text":"Video Signal Listen This is not part of the MediaRouter library but it is a useful tool for automation of a lot of the tests in MediaRouter pack. Usage, Imports: from nextgen.video_signal import ( wait_for_video, wait_for_no_video ) Usage: wait_for_video(20) wait_for_no_video(20) The argument passed (int) is the time we should wait for a video signal or no video signal in seconds .","title":"Video Signal Check"},{"location":"video_listener/#video-signal-listen","text":"This is not part of the MediaRouter library but it is a useful tool for automation of a lot of the tests in MediaRouter pack. Usage, Imports: from nextgen.video_signal import ( wait_for_video, wait_for_no_video ) Usage: wait_for_video(20) wait_for_no_video(20) The argument passed (int) is the time we should wait for a video signal or no video signal in seconds .","title":"Video Signal Listen"}]}